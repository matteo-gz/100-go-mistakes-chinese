[{"id":0,"href":"/100-go-mistakes-chinese/docs/ch1/","title":"01. 易学难精的GO","section":"Docs","content":"go官方的答疑 https://go.dev/doc/faq\ngo语言的特征\n简单 简洁表达 编译速度快 安全 go的犯错归类\n漏洞 画蛇添足,提高无必要代码复杂度 他人难解读的代码 不良好的代码组织方式 缺乏API封装 欠缺代码优化 缺乏生产力 "},{"id":1,"href":"/100-go-mistakes-chinese/docs/ch2/","title":"02. 代码与项目组织","section":"Docs","content":" 1 变量阴影 # package main import \u0026#34;fmt\u0026#34; func main() { // 外部作用域变量 x := 10 // 这是一个新的代码块，内部作用域 { // 在内部作用域中重名了一个变量x x := 5 fmt.Println(\u0026#34;内部作用域中的x:\u0026#34;, x) // 输出：内部作用域中的x: 5 } // 注意：外部作用域中的变量x没有被修改，因为它被内部作用域中的x所掩盖 fmt.Println(\u0026#34;外部作用域中的x:\u0026#34;, x) // 输出：外部作用域中的x: 10 } 运行之后output:\n内部作用域中的x: 5\n外部作用域中的x: 10\n解决办法 IDE GoLand 能识别这个风险,新作用域内的x变量会变成绿色字体. 临时变量 用一个临时变量tmpX来过渡,防止2个地方的x变量指向的混淆.\nx:=10 { tmpX:=5 x=tmpX } 不用:= 要么不用:=\nvar x int x=10 { x=5 } 2 代码嵌套 # 涉及卫语句概念.\n多层嵌套例子 ↕ if（it == 活的）{ if（it == 人）{ if（it ！= 女人）{ return 不喜欢； } else { return 喜欢； } } else { return 不喜欢； } } else { return 不喜欢； } 改成如下精简的:\nif （it ！= 活的）{return 不喜欢} if（it！=人）{return 不喜欢} if（it！=女人）{return 不喜欢} if（it == 女人 \u0026amp;\u0026amp; it == 活的） {return 喜欢} if（其他任何情况）{return 不喜欢} 3 init函数使用场景 # init与其他函数执行顺序 package main import \u0026#34;fmt\u0026#34; var va = func() int { fmt.Println(\u0026#34;var\u0026#34;) return 1 }() func init() { fmt.Println(\u0026#34;init\u0026#34;) } func main() { fmt.Println(\u0026#34;main\u0026#34;) } output:\nvar\ninit\nmain\n多个包的init函数执行顺序 func main(){ redis.xx } 先载入redis的init,然后是main的init.\nimport多个包的顺序 import多个包时,根据文件字母顺序载入init,比如b.go,a.go. 先执行a.go的init.\n多次定义init函数 init函数可以多处定义.\nfunc init() { fmt.Println(\u0026#34;init\u0026#34;) } func init() { fmt.Println(\u0026#34;init2\u0026#34;) } 先执行第一个init.\n初始化其他包的init import ( _ \u0026#34;foo\u0026#34; ) 上面例子中foo包的init被执行了. init函数无法被其他函数调用 使用场景\n反例:\n数据库连接例子写在init函数里可能是不合适的.\n// 伪代码 var db *DB fun init(){ db，err=xx() if err!=nil{ painc } } init函数没有返回值,只能panic去中断,而数据库返回的error,只能暴力处理 考虑到单元测试场景,init是首次被加载的,包里的函数不是每个测试时都需要数据库连接这个依赖项 使得变量全局化了,过于暴露了数据库这个变量 正例\nfunc init(){ http.HandleFunc(\u0026#34;/blog/\u0026#34;, redirect) } error的handle还是正常的 单元测试没有变复杂 4 设置变量值复杂化 # 通过函数设置变量\nfunc setAge(){ //setter } func Age(){ // getter } 优点\n统一管理 可以在函数内部对变量作出规则限制 很方便植入断点 若前期需求简单,不要过度设计.\n5 interface污染 # 接口越大,抽象越弱.\n定义接口规则\n共同行为 解耦合 约束行为 不要去设计接口,而是发现他们.\n接口有CPU消耗成本.\n6 interface定义处 # 接口的定义尽量在消费端,而不是在生产端.\n7 interface使用规则 # 函数返回对象尽量不要用interface,否则别人使用时,需要去看你的代码.\n函数入参可以接受interface,宽进严出.\n8 any类型使用 # any使得静态语言变得和动态语言一样,不确定里面的信息.\n除非在json encode和decode场景这种,尽量减少用any,因为他代表着信息表征减少.\n9 泛型使用 # 场景\nslice里面的元素合并 10 struct内嵌类型 # type a struct { sync.Mutex } func useA() { a1 := new(a) a1.Lock() } a1.Lock 对于使用者过于迷惑.\ntype a struct { mu sync.Mutex } func useA() { a1 := new(a) a1.mu.Lock() } a1.mu.Lock 对于使用者不会感到迷惑.\n11 设计模式:func option # functional options pattern golang\nfunc WithPort(port int) Option { return func(s *Server) { s.port = port } } func WithTimeout(timeout time.Duration) Option { return func(s *Server) { s.timeout = timeout } } 12 项目布局 # go标准布局\nhttps://github.com/golang-standards/project-layout\n13 package名定义 # 减少这种common utils base包名的定义.\n14 package名冲突 # 使用别名解决.\n15 代码文档 # 提及代码文档重要性,推荐go官方的go doc工具.\n16 静态代码检测 # 介绍集成的linter的项目https://github.com/golangci/golangci-lint\n"},{"id":2,"href":"/100-go-mistakes-chinese/docs/ch3/","title":"03. 数据类型","section":"Docs","content":" 17 八进制混淆 # 代码可读性\nfmt.Println(100 + 010) //结果 108 fmt.Println(100 + 0o10) //结果 108 fmt.Println(100+010 == 100+0o10) // true 八进制表达最好用0o前缀.\n二进制用0b前缀.\n十六进制用0x前缀.\n虚数 使用i后缀,例如 3i.\n18 整数溢出 # 当一个数据超过范围,每次需要增加额外逻辑来判断处理是否溢出.\nvar counter int32 = math.MaxInt32 fmt.Printf(\u0026#34;counter=%d\\n\u0026#34;, counter) counter++ fmt.Printf(\u0026#34;counter=%d\\n\u0026#34;, counter) counter=2147483647\ncounter=-2147483648\n19 浮点数理解 # 浮点数溢\nvar n float32 = 1.0001 fmt.Println(n * n) // 应该是1.00020001 但是结果是\n1.0002\n20 slice 底层结构 # len与cap的关系.\n21 slice 初始化问题 # func convert(foos []Foo) []Bar { // 第一种低效的 bars := make([]Bar, 0) // 第二种高效的 n := len(foos) bars := make([]Bar, 0, n) // 因为不知道slice里面的元素数量,如果slice过大则需要多次扩容 for _, foo := range foos { bars = append(bars, fooToBar(foo)) } return bars } 关于append的处理\n偏向可读性做法:\nfunc collectAllUserKeys(cmp Compare, tombstones []tombstoneWithLevel) [][]byte { keys := make([][]byte, 0, len(tombstones)*2) for _, t := range tombstones { keys = append(keys, t.Start.UserKey) keys = append(keys, t.End) } // ... } 偏向性能做法:\nfunc collectAllUserKeys(cmp Compare, tombstones []tombstoneWithLevel) [][]byte { keys := make([][]byte, len(tombstones)*2) for i, t := range tombstones { keys[i*2] = t.Start.UserKey keys[i*2+1] = t.End } // ... } 22 slice: nil与 empty slices 区别 # len==0 就是empty slices slice==nil 就是 nil slice var s []string // empty 且nil s = []string(nil) // empty 且nil s = []string{} // 只是empty s = make([]string, 0) // 只是empty nil没有内存分配.\njson encode影响\nvar s1 []float32 // nil customer1 := customer{ ID: \u0026#34;foo\u0026#34;, Operations: s1, } {\u0026ldquo;ID\u0026rdquo;:\u0026ldquo;foo\u0026rdquo;,\u0026ldquo;Operations\u0026rdquo;:null}\n第2种\ns2 := make([]float32, 0) // 非nil customer2 := customer{ ID: \u0026#34;bar\u0026#34;, Operations: s2, } {\u0026ldquo;ID\u0026rdquo;:\u0026ldquo;bar\u0026rdquo;,\u0026ldquo;Operations\u0026rdquo;:[]}\n23 slice: nil处理不当的bug # func handleOperations(id string) { operations := getOperations(id) if operations != nil { // 如果有操作就是要去处理 handle(operations) } } func getOperations(id string) []float32 { operations := make([]float32, 0) // 此处已经非nil了 if id == \u0026#34;\u0026#34; { return operations // 逻辑1 误以为是nil,其实此处返回了非nil return nil // 逻辑2 返回nil // 此处应该选择逻辑2处理才是正确的 } operations=append(operations,1.0) return operations // 非nil } 另一种方案\nfunc handleOperations(id string) { operations := getOperations(id) //if operations != nil { // 改为判断长度 if len(operations) != 0 { // 如果有操作就是要去处理 handle(operations) } } 24 slice: 没有正确copy # 下面例子\n错误的\nsrc := []int{0, 1, 2} var dst []int copy(dst, src) fmt.Println(\u0026#34;dst:\u0026#34;, dst,len(dst),cap(dst)) output:\ndst: [] 0 0\n正确的\nsrc := []int{0, 1, 2} dst := make([]int, len(src)) copy(dst, src) fmt.Println(\u0026#34;dst:\u0026#34;, dst) output:\ndst: [0 1 2]\n这种语法也能拷贝的\nsrc := []int{0, 1, 2} dst := append([]int(nil), src...) fmt.Println(\u0026#34;dst:\u0026#34;, dst) output:\ndst: [0 1 2]\n25 slice: append的注意点 # s1 := []int{1, 2, 3} s2 := s1[1:2] s3 := append(s2, 10) fmt.Println(s1, s2, s3) 结果会是怎样呢?\n或许你会猜测是: // [1,2,3] [2] [2,10]\n但真实的output:\n[1 2 10] [2] [2 10]\n因为他们指向同个底层array,当append发生,len没有超出cap时,s1[2]被修改到了.\n类似同样的现象\nfunc main() { s := []int{1, 2, 3} // s[:2]// [1,2] but cap is 3 f(s[:2]) fmt.Println(s) // [1 2 10] } func f(s []int) { _ = append(s, 10) } 那么如何保护slice,不受上下文被改动到呢?\n通过copy函数,使用新变量 利用s[low:high:max] 这种的表达式,cap==max-low f(s[:2:2]) // 即s[0:2:2] cap==2-0 -\u0026gt;2 // 调用时则不会改动原有的s 26 slice 与内存泄漏 # 例子 我们调用consumeMessages\nfunc consumeMessages() { i := 1000 var m runtime.MemStats for { runtime.ReadMemStats(\u0026amp;m) fmt.Println(\u0026#34;Allocated memory (bytes):\u0026#34;, m.Alloc) // getMessageType 2199560 // getMessageType2 1199236608 if i == 0 { break } i-- msg := receiveMessage() storeMessageType(getMessageType2(msg)) } fmt.Println(\u0026#34;ok\u0026#34;) } func receiveMessage() []byte { s := \u0026#34;1\u0026#34; b := strings.Repeat(s, 100*10000) return []byte(b) } var a [][]byte func storeMessageType(b []byte) { a = append(a, b) } func getMessageType(msg []byte) []byte { return msg[:5] } func getMessageType2(msg []byte) []byte { msgType := make([]byte, 5) copy(msgType, msg) // 新的变量 return msgType } getMessageType与getMessageType2相差内存占有不一样\ngetMessageType 2199560\ngetMessageType2 1199236608 getMessageType2方法是有效的.\n那么如果getMessageType下面这种处理有效吗?\nfunc getMessageType(msg []byte) []byte { return msg[:5:5] // 之前的写法是 msg[:5] } 答案是改成msg[:5:5]也是无效处理\nslice与指针\n例子 我们调用a1\n第一种 无法垃圾回收\ntype Foo struct{ v []byte } func printAlloc() { var m runtime.MemStats runtime.ReadMemStats(\u0026amp;m) fmt.Printf(\u0026#34;%d KB\\n\u0026#34;, m.Alloc/1024) } func a1() { foos := make([]Foo, 1_000) printAlloc() for i := 0; i \u0026lt; len(foos); i++ { foos[i] = Foo{ v: make([]byte, 1024*1024), } } printAlloc() two := keepFirstTwoElementsOnly(foos) runtime.GC() printAlloc() runtime.KeepAlive(two) // 此时 foos 底层数组被强行留着 } func keepFirstTwoElementsOnly(foos []Foo) []Foo { return foos[:2] } 104 KB\n1024108 KB\n1024109 KB\n第二种 可以回收\nfunc keepFirstTwoElementsOnly2(foos []Foo) []Foo { res := make([]Foo, 2) // 消耗成本取决于cap(res)的大小 copy(res, foos) return res } 104 KB\n1024110 KB\n2159 KB\n第三种 也可以垃圾回收\nfunc keepFirstTwoElementsOnly3(foos []Foo) []Foo { // 消耗成本取决于len(foos)的大小 for i := 2; i \u0026lt; len(foos); i++ { foos[i].v = nil } return foos[:2] } 104 KB\n1024107 KB\n2157 KB\n关于第二种和第三种做法,哪种好取决于你的场景以及做的基准测试.\n27 map初始化 # // 有初始化容量的 m := make(map[string]int, 1_000_000) BenchmarkMapWithoutSize-4 6 227413490 ns/op BenchmarkMapWithSize-4 13 91174193 ns/op 作者压测后得出有初始化数量更高效.\n文中解释了这一现象原因:一个合理数量的初始化,不用动态创建bucket以及重新平衡bucket,从而高效.\n28 map与内存泄漏 # 例子\nfunc mapGc() { n := 1_000_000 m := make(map[int][128]byte) printAlloc() for i := 0; i \u0026lt; n; i++ { m[i] = randBytes() } printAlloc() for i := 0; i \u0026lt; n; i++ { delete(m, i) } runtime.GC() printAlloc() runtime.KeepAlive(m) } func randBytes() [128]byte { return [128]byte{} } 104 KB\n472504 KB\n300441 KB\n结论是垃圾回收了,但是没有想象中的回收的多,此处涉及map的底层数据结构.\n存在的bucket没变化,只是里面的slots变成了0,map只能不断的增长,拥有更多的bucket,而不会缩小\n探讨: 一场活动导致的流量高峰,高峰过后因为map的占用内存导致服务器的内存处于高位,而回收不太理想\n每隔一小时复制到新map,丢弃旧map 优化数据类型 map[int][128]byte变成map[int]*[128]byte,改为指针能节省部分内存 29 判断类型等价关系 # == 不能用于slice map.\nreflect.DeepEqual() 可以做到,但是性能很一般.\n"},{"id":3,"href":"/100-go-mistakes-chinese/docs/ch4/","title":"04. 控制结构","section":"Docs","content":" 30 range下元素copy # range介绍 range 可作用于 string, array, 指针数组, slice, map, 接收chan.\n复习下range的写法:\ns := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} for i, v := range s { fmt.Printf(\u0026#34;index=%d, value=%s\\n\u0026#34;, i, v) } for _, v := range s { fmt.Printf(\u0026#34;value=%s\\n\u0026#34;, v) } for i := range s { fmt.Printf(\u0026#34;index=%d\\n\u0026#34;, i) } output:\nindex=0, value=a index=1, value=b index=2, value=c value=a value=b value=c index=0 index=1 index=2 range下值类型 accounts := []account{{balance: 100.}, {balance: 200.}, {balance: 300.}} for _, a := range accounts { a.balance += 1000 } fmt.Println(accounts) [{100} {200} {300}]\n因为我们修改的是拷贝出来的a 原来的slice没有改变到\n下面才是能改变的\nfor i := range accounts { accounts[i].balance += 1000 } 或者\nfor i := 0; i \u0026lt; len(accounts); i++ { accounts[i].balance += 1000 } 那么这种改法呢 accounts := []*account{} 作者不是很赞同,在#91时会提及\n31 range下元素计算 # slice\ns在range时被拷贝 func sliceCopy() { s := []int{0, 1, 2} for range s { s = append(s, 10) } fmt.Println(s) } [0 1 2 10 10 10]\n陷入死循环,因为s每次迭代都是重新求值 func sliceNeverStop() { s := []int{0, 1, 2} for i := 0; i \u0026lt; len(s); i++ { s = append(s, 10) } fmt.Println(s) } channel 在range时拷贝值,类似slice func chanCopy() { ch1 := make(chan int, 3) ch2 := make(chan int, 3) go func() { ch1 \u0026lt;- 1 ch1 \u0026lt;- 11 ch1 \u0026lt;- 111 close(ch1) }() go func() { ch2 \u0026lt;- 2 ch2 \u0026lt;- 22 ch2 \u0026lt;- 222 close(ch2) }() ch := ch1 for v := range ch { fmt.Println(v) // 保持ch1的来源,copy in range first time // 此时v的来源是ch1的值 ch = ch2 } fmt.Println(\u0026#34;---\u0026#34;) for v := range ch { // ch 还是被ch2 赋值了 fmt.Println(v) } } output\n1 11 111 --- 2 22 222 array 在range时发生拷贝 func arrayCopy() { arr := [3]int{0, 1, 2} for i, v := range arr { arr[2] = 10 if i == 2 { fmt.Println(v) } } fmt.Println(arr) } output\n2 [0 1 10] array 指针指向源数据 func arrayCopy() { arr := [3]int{0, 1, 2} for i, v := range \u0026amp;arr { //此时为指针 arr[2] = 10 if i == 2 { fmt.Println(v) } } fmt.Println(arr) } output\n10 [0 1 10] 32 range下指针元素 # range时临时变量指向同个指针\ntype Customer struct { ID string Balance float64 } type Store struct{ m map[string]*Customer } func (s *Store) storeCustomers(customers []Customer) { for _, customer := range customers { // 此时customer 在每次迭代中都是同一指针 s.m[customer.ID] = \u0026amp;customer } } func rangeLast() { s := Store{ m: map[string]*Customer{}, } s.storeCustomers([]Customer{{ID: \u0026#34;1\u0026#34;, Balance: 10}, {ID: \u0026#34;2\u0026#34;, Balance: -10}, {ID: \u0026#34;3\u0026#34;, Balance: 0}}) for _, v := range s.m { fmt.Println(v) } } \u0026amp;{3 0} \u0026amp;{3 0} \u0026amp;{3 0} 化解\nfunc (s *Store) storeCustomers(customers []Customer) { for _, customer := range customers { customer1 := customer s.m[customer.ID] = \u0026amp;customer1 } } output\n\u0026amp;{1 10} \u0026amp;{2 -10} \u0026amp;{3 0} 33 map迭代陷阱 # map的迭代无序性 在同一迭代中操作元素 func rangeMap() { m := map[int]bool{ 0: true, 1: false, 2: true, } for k, v := range m { if v { m[10+k] = true } } fmt.Println(m) } 无序的体现,在map range中改变map,每次生成都是无序.\n建议用新变量m2来存储赋值结果.\n34 break工作机制 # break只终结当前循环 func breakCurr() { for i := 0; i \u0026lt; 5; i++ { fmt.Printf(\u0026#34;%d \u0026#34;, i) switch i { default: case 2: break } } } output\n0 1 2 3 4 化解\nfunc breakCurr() { loopLabel: for i := 0; i \u0026lt; 5; i++ { fmt.Printf(\u0026#34;%d \u0026#34;, i) switch i { default: case 2: break loopLabel } } } output\n0 1 2 例子2\nfunc breakFor() { ch := make(chan int, 3) ctx, canF := context.WithCancel(context.Background()) go func() { time.Sleep(1 * time.Second) canF() }() for { select { case \u0026lt;-ch: fmt.Println(\u0026#34;from ch\u0026#34;) case \u0026lt;-ctx.Done(): // Do something case \u0026lt;-ctx.Done(): fmt.Println(\u0026#34;wanna break for and exit\u0026#34;) break } } } 以上函数无法中终结,只break select\n同样修复方式:\nfunc breakFor() { ch := make(chan int, 3) ctx, canF := context.WithCancel(context.Background()) go func() { time.Sleep(1 * time.Second) canF() }() loopLabel: for { select { case \u0026lt;-ch: fmt.Println(\u0026#34;from ch\u0026#34;) break case \u0026lt;-ctx.Done(): // Do something case \u0026lt;-ctx.Done(): fmt.Println(\u0026#34;wanna break for and exit\u0026#34;) break loopLabel } } fmt.Println(\u0026#34;im arrive\u0026#34;) } output\nwanna break for and exit im arrive 35 在for中使用defer # defer的执行是推入函数的调用栈,在函数return时才会执行.\n如果在for循环中打开文件,defer关闭文件句柄的行为存在风险\n建议其一,将打开文件,defer关闭文件放在一个函数,在for中调用单独函数,保证defer的执行\n"},{"id":4,"href":"/100-go-mistakes-chinese/docs/ch5/","title":"05. strings","section":"Docs","content":" 36 string相关rune概念 # charset encoding,golang使用UTF-8 s := \u0026#34;hello\u0026#34; fmt.Println(len(s)) // 5 s := \u0026#34;汉\u0026#34; fmt.Println(len(s)) // 3 s := string([]byte{0xE6, 0xB1, 0x89}) fmt.Printf(\u0026#34;%s\\n\u0026#34;, s)// 汉 rune 即 unicode.\nlen 返回的byte count.\n37 strings迭代 # s := \u0026#34;hêllo\u0026#34; for i := range s { fmt.Printf(\u0026#34;position %d: %c\\n\u0026#34;, i, s[i]) } fmt.Printf(\u0026#34;len=%d\\n\u0026#34;, len(s)) output:\nposition 0: h position 1: Ã position 3: l position 4: l position 5: o len=6 改用rune\ns := \u0026#34;hêllo\u0026#34; runes := []rune(s) for i, r := range runes { fmt.Printf(\u0026#34;position %d: %c\\n\u0026#34;, i, r) } fmt.Printf(\u0026#34;len=%d\\n\u0026#34;, len(runes)) output:\nposition 0: h position 1: ê position 2: l position 3: l position 4: o len=5 string默认在byte数组中的迭代,底层用的UTF-8识别.\nlen的计算可以使用utf8.RuneCountInString(s)获取真实rune数.\n[]rune(s)的转换并非魔法,使用时产生了运行时计算开销.\n38 string相关trim函数 # fmt.Println(strings.TrimRight(\u0026#34;123oxo\u0026#34;, \u0026#34;xo\u0026#34;)) // 123 fmt.Println(strings.TrimSuffix(\u0026#34;123oxo\u0026#34;, \u0026#34;xo\u0026#34;)) //123o fmt.Println(strings.TrimLeft(\u0026#34;oxo123\u0026#34;, \u0026#34;ox\u0026#34;)) // 123 fmt.Println(strings.TrimPrefix(\u0026#34;oxo123\u0026#34;, \u0026#34;ox\u0026#34;)) /// o123 fmt.Println(strings.Trim(\u0026#34;oxo123oxo\u0026#34;, \u0026#34;ox\u0026#34;)) // 123 具体的函数定义处有详细说明\n39 string接连 # 对于少量字符拼接,保持易读性. 使用fmt += 拼接都可以\n对于大量字符,使用builder函数,并且设置grow可有良好的优化.\n写多个拼接函数版本,然后压测即可.上述的只是结论.\n40 string转换 # 很多接口的操作是[]byte操作,改为string操作存在转换消耗.\n41 substrings与内存泄漏 # 占据同个内存,可见#26\nuuid := log[:36] s.store(uuid) 改为让slice脱离释放\nuuid := strings.Clone(log[:36]) "},{"id":5,"href":"/100-go-mistakes-chinese/docs/ch6/","title":"06. 函数与方法","section":"Docs","content":" 42 接收者与指针 # 没有改变原始数据\nfunc (c customer) add(v float64) { c.balance += v } 改变原始数据\nfunc (c *customer) add(operation float64) { c.balance += operation } 43 返回值进行命名 # getCoordinates(address string) (float32, float32, error) 更为清晰\ngetCoordinates(address string) (lat, lng float32, err error) 44 返回值非预期 # 忘记赋值err,导致err是nil\nfunc returnAlwaysNil(ctx context.Context) (err error) { if ctx.Err() != nil { return err } return nil } error被覆盖,本来期望返回\u0026quot;new err\u0026quot;\nfunc returnErrCover(ctx context.Context) (err error) { err = errors.New(\u0026#34;new err\u0026#34;) if err := ctx.Err(); err != nil { return err // return \u0026#34;context canceled\u0026#34; cover \u0026#34;new err\u0026#34; } return nil } 45 接收者nil # type MultiError struct { errs []string } func (m *MultiError) Add(err error) { m.errs = append(m.errs, err.Error()) } func (m *MultiError) Error() string { return strings.Join(m.errs, \u0026#34;;\u0026#34;) } type Customer struct { Age int Name string } func (c Customer) Validate() error { var m *MultiError if c.Age \u0026lt; 0 { m = \u0026amp;MultiError{} m.Add(errors.New(\u0026#34;age is negative\u0026#34;)) } if c.Name == \u0026#34;\u0026#34; { if m == nil { m = \u0026amp;MultiError{} } m.Add(errors.New(\u0026#34;name is nil\u0026#34;)) } return m } // 调用 func show() { customer := Customer{Age: 33, Name: \u0026#34;John\u0026#34;} if err := customer.Validate(); err != nil { fmt.Printf(\u0026#34;customer is invalid: %v\u0026#34;, err) } } customer is invalid: \u0026lt;nil\u0026gt; 以上本质是var m *MultiError\nm作为*MultiError == nil\n但是m却实现了error interface 作为error 不是nil\ntype error interface { Error() string } 修复方案\nfunc (c Customer) Validate() error { // ... if m != nil { return m } return nil } 简化版理解\ntype mErr struct { errs []string } func (m *mErr) Error() string { return strings.Join(m.errs, \u0026#34;;\u0026#34;) } func simpleErr() { var m *mErr var e2 error e2 = m if err := e2; err != nil { fmt.Printf(\u0026#34;err:%v\u0026#34;, err) } } output:\nerr:\u0026lt;nil\u0026gt; 涉及知识点为interface的值与类型判断\n46 文件名作为参数的缺点 # 文件名作为参数的缺点,不利于单元测试.\n解决方案为io.Reader作为参数,即接口的优点,抽象代替实际.\n47 defer arguments与接收者 # 单词parameter与arguments,通常在英文上下文中为形参与实参的区别.\ndefer的陷阱 func deferFn2(s int) { fmt.Println(\u0026#34;defer :\u0026#34;, s) } func deferFn1() { var s int defer deferFn2(s) s = 1 return } output:\ndefer : 0 改法:\nfunc deferFn5() { var s int defer func() { deferFn2(s) }() s = 1 return } output:\ndefer : 1 传递通过指针 func deferFn3(s *int) { fmt.Println(\u0026#34;defer :\u0026#34;, *s) } func deferFn1() { var s int defer deferFn3(\u0026amp;s) s = 1 return } output:\ndefer : 1 闭包传递 func deferFn4() { i := 0 j := 0 defer func(i int) { fmt.Println(i, j) }(i) i++ j++ } output:\n0 1 即刻打印 func main2() { s := Struct{id: \u0026#34;foo\u0026#34;} defer s.print() s.id = \u0026#34;bar\u0026#34; } type Struct struct { id string } func (s Struct) print() { fmt.Println(s.id) } output:\nfoo 指针类型 func main2() { s := \u0026amp;Struct2{id: \u0026#34;foo\u0026#34;} defer s.print() s.id = \u0026#34;bar\u0026#34; } type Struct2 struct { id string } func (s *Struct2) print() { fmt.Println(s.id) } output:\nbar "},{"id":6,"href":"/100-go-mistakes-chinese/docs/ch7/","title":"07. 错误管理","section":"Docs","content":" 48 panic # panic与recover机制\n何时panic场景,举例\nnet/http 包中存在header code越界panic database/sql中 register函数,若driver nil 为panic 49 错误修饰 # 用法\nfmt.Errorf(\u0026quot;%w\u0026quot;,err) 可显示源错误,用于errors.Is判断 fmt.Errorf(\u0026quot;%v\u0026quot;,err) 不显示源错误 // 一个原始错误 underlying := errors.New(\u0026#34;underlying error\u0026#34;) // 使用 %w 报告原始错误 wrapped := fmt.Errorf(\u0026#34;%w\u0026#34;, underlying) // wrapped 会包含原始错误的信息 fmt.Println(\u0026#34;wrapped:\u0026#34;, wrapped) // underlying error // 检查 wrapped 是否包含原始错误 if errors.Is(wrapped, underlying) { fmt.Println(\u0026#34;%w 报告原始错误\u0026#34;) } 场景\n遮罩错误,向用户展示人性化提示,并记录错误上下文 叠加错误,多个失败堆叠 50 错误类型检查 # errors.As 可用于类型判断\nerr := DoSomething() if errors.As(err, \u0026amp;MyError{}); err != nil { // err implements MyError handleMyError(err) } else { // err does not implement MyError handleGenericError(err) } 51 检查错误值不准确 # fmt.Errorf和%w的错误传递的情况下,\n用==判断错误不可靠,错误有可能被修饰了.\n可用errors.Is判断.\n// err 可能被fmt.Errorf(\u0026#34;...%w...\u0026#34; 修饰过 if errors.Is(err, sql.ErrNoRows){ //... } 52 重复处理错误 # 错误保持精简,多次错误传递时用%w组合传递错误\n53 未处理错误 # 抑制错误,可能会丢失错误分支\n// 函数定义 func notify()error // 用例 // ... notify() // 直接调用,抑制错误发生可能 // ... 54 不处理defer中的错误 # 建议用日志记录错误\n// 函数定义 func close() error // 用例 直接defer函数,没有处理返回error defer close() 修改后\ndefer func(){ err:=close() if err!=nil{ log(err) } } "},{"id":7,"href":"/100-go-mistakes-chinese/docs/ch8/","title":"08. 基础并发","section":"Docs","content":" 55 并发与并行 # 并行即同一时刻,多道任务同时处理.\n并发是交替执行,表现在一段时间内完成了多个任务.\n56 调度的成本 # golang协程成本. 文中提及调度原理.\n57 chan 与 mutex # 搭配使用\n58 data race # 多个协程计数器增加时,发生data race, 可用sync/atomic,或者mutex,chan\n59 工作负载与并发 # 工作负载因素\nCPU速度 I/O速度 可用内存 上述因素下并发场景的设计\n60 context # 功能\ndeadline time.Duration // 从开始持续的时间,比如250 ms time.Time// 时间节点,比如2022-02-02 00:00:00 UTC 取消信号 context values context.done "},{"id":8,"href":"/100-go-mistakes-chinese/docs/ch9/","title":"09. 实践并发","section":"Docs","content":" 61 context传递错误 # 若一个context变量无法应对多个场景\n新建context.background 建造新context,只传递context values 62 协程何时终止 # goroutine 泄漏\n记得关闭的资源\nHTTP 数据库连接 打开文件 socket 资源的关闭机制\n在main函数执行时,通过context的传递来控制协程,或者defer关闭(作者推荐这个,因为defer保证执行).\nw:=newWatcher() defer w.close() // 在对应的close 触发终止 func (watcher) close (){ // 写上资源的回收 } 63 协程的时序 # 在for循环中不断地创建协程,他们执行的顺序是没有先后的.\n64 select与channels # select与channels搭配保证时序\nselect { case v:=\u0026lt;-ch: } 65 信号与channels # chan struct{} 承担信号的变化,减少内存占用和符号意义代表.\n66 nil channels # 利用nil chan阻塞 合并chan消息时,用nil chan避免CPU空转 67 channel size # size为0,易于推理逻辑,同步模式\nsize为40,CPU与内存平衡\nsize过大要思考crash时场景以及内存占用.\n68 string格式 # 1个协程context更新值;1个协程fmt打印context造成数据竞争,案例:https://github.com/etcd-io/etcd/pull/7816\nfmt 打印结构体时会调用String()接口\n69 data race与append # 存在多个goroutine append slice操作时导致data race.\n因为slice可能指向同个底层数组,在数据修改时就存在数据竞争.\n70 mutex与map # 在考虑map的data race,确定mutex的边界,在保证线程安全情况下,提高并发程度,减少锁占用时间.\n71 waitGroup误用 # go func(){ wg.Add(1) //wg的数量存在情况:即由于协程有几率执行比wg.wait慢,从而挂不上. wg.Done() } wg.Wait() 这种情况下存在bug\nwg.Add(1) // wg的数量已经挂上 go func(){ wg.Done() } wg.Wait() 以上保证了wg的数量有被挂上,而非goroutine数量过多时,得不到执行.\n72 sync.Cond # 监听balance是否到达goal,mutex的实现例子\nvar mu sync.RWMutex //... // 读锁 监听 mu.RLock() defer mu.RUnlock() for balance\u0026lt; goal{ // 陷入loop CPU损耗 mu.RUnlock() mu.RLock() } fmt.Printf(\u0026#34;到达\u0026#34;) //... // 写锁 操作数据 mu.Lock() defer mu.Unlock() balance++ 上述场景,每次去窥探是否到达goal时,一直陷入循环.\n利用chan改造\nch:=make (chan int) //... //读取 监听 for balance:=range ch{ if balance\u0026gt;= goal{ return\t} } // ... // 写入 balance++ ch\u0026lt;-balance 当写入有变化时,对比第一种方案有所优化.\n但是只能设置一个读取函数,若存在同时监听2个目标时,比如:\nbalance与 goal=10, goal=11比较时chan只能被读取一次,下次无法读取了.\ncond 广播机制\nvar cond *sync.Cond=sync.NewCond(\u0026amp;sync.Mutex{}) //... // 读监听 cond.L.Lock() defer cond.L.Unlock() for balance\u0026lt;goal { // loop cond.Wait() // 挂起等待唤醒 } fmt.Printf(\u0026#34;到达\u0026#34;) // ... // 写 cond.L.Lock() defer cond.L.Unlock() balance++ cond.Broadcast() // 广播 利用广播,可满足多个goal设置值监听\n73 errgroup # 多goroutine协助,errgroup妙用\n//... g,ctx:=errgroup.WithContext(ctx) for _,v:= range data{ g.Go( func()error{ err:=xx(ctx,v) // xx 为业务函数 return err } ) } err:=g.Wait() 引入errgroup包,使用WithContext来创建一个errgroup,并传入上下文ctx。\n使用errgroup的Go方法,为每个data循环起一个goroutine调用业务函数xx。这里xx函数必须接收ctx作为参数,因为需要读取ctx中的取消信号。\nerrgroup的Go方法会将每个任务以goroutine的形式运行,并将错误返回替换为errgroup中管理的错误。\n调用errgroup的Wait方法,会阻塞等待所有任务完成。如果其中有任务返回错误,则Wait最终会返回第一个错误。\n可以在ctx中设置取消信号,此时所有goroutine都会收到取消消息退出。\n73 复制sync # sync包永远不该被复制类型\nsync.Cond sync.Map sync.Mutex sync.RWMutex sync.Once sync.Pool sync.WaitGroup 案例:\ntype Counter struct { mu sync.Mutex counters map[string]int } func NewCounter() Counter { return Counter{counters: map[string]int{}} } func (c Counter) Increment(name string) { c.mu.Lock() defer c.mu.Unlock() c.counters[name]++ } func syncCp() { counter := NewCounter() for i := 0; i \u0026lt; 100; i++ { go func() { counter.Increment(\u0026#34;foo\u0026#34;) }() go func() { counter.Increment(\u0026#34;bar\u0026#34;) }() } } syncCp调用会\nfatal error: concurrent map writes 修复方法1:\nIDE提示为\n\u0026lsquo;Increment\u0026rsquo; passes a lock by the value: type \u0026lsquo;Counter\u0026rsquo; contains \u0026lsquo;sync.Mutex\u0026rsquo; which is \u0026lsquo;sync.Locker\u0026rsquo;\n修复后\nfunc (c *Counter) Increment(name string) //修改为指针接收者 修复方法2:\ntype Counter struct { mu *sync.Mutex // 指针类型 counters map[string]int } func NewCounter() Counter { return Counter{ counters: map[string]int{}, mu: \u0026amp;sync.Mutex{}, // 指向同个,若此处为nil 也会panic } } "},{"id":9,"href":"/100-go-mistakes-chinese/docs/ch10/","title":"10. 标准库","section":"Docs","content":" 75 提供错误的time duration # 没有单位写法会带来误导.\nticker := time.NewTicker(1000) 附带单位\nticker := time.NewTicker(1000 * time.Nanosecond) 76 time.After内存泄漏 # func f1(ch \u0026lt;-chan int) { for { select { case event := \u0026lt;-ch: fmt.Println(event) case \u0026lt;-time.After(time.Hour): log.Println(\u0026#34;warning: no messages received\u0026#34;) } } } 每次走select分支都是新创建time.After,time.After里面包裹着chan且要等待1小时候释放.\n修复问题\nfunc f3(ch \u0026lt;-chan int) { for { ctx, cancel := context.WithTimeout(context.Background(), time.Hour) select { case event := \u0026lt;-ch: cancel() // chan得到释放 fmt.Println(event) case \u0026lt;-ctx.Done(): log.Println(\u0026#34;warning: no messages received\u0026#34;) } } } 或者最佳实践(因为变量复用)\nfunc f4(ch \u0026lt;-chan int) { timeD := time.Hour timer := time.NewTimer(timeD) for { timer.Reset(timeD) select { case event := \u0026lt;-ch: fmt.Println(event) case \u0026lt;-timer.C: log.Println(\u0026#34;warning: no messages received\u0026#34;) } } } 77 json处理 # 类型内嵌导致的意外 func json1() { event := Event{ID: 1234, Time: time.Now()} b, err := json.Marshal(event) if err != nil { fmt.Println(err) return } fmt.Println(string(b)) } type Event struct { ID int time.Time } \u0026#34;2023-10-27T18:54:09.695182+08:00\u0026#34; 上文ID: 1234消失了?\n举个简单例子 ↕ type Person struct { name string age int AB int } type Event1 struct { ID int // 导出 Person // 内嵌 匿名 } func json2() { e := Event1{ ID: 1, Person: Person{ name: \u0026#34;John\u0026#34;, age: 30, AB: 1, }, } // 序列化 data, _ := json.Marshal(e) fmt.Println(string(data)) } func (Person) MarshalJSON() ([]byte, error) { return []byte(`2023`), nil } 2023 因为time.Time也类似的实现了MarshalJSON() ([]byte, error) 这个接口. 影响了json.Marshal的行为\n修复方法\n都导出\ntype Event struct { ID int Time time.Time } 或者修改实现\nfunc (e Event) MarshalJSON() ([]byte, error) { return json.Marshal(struct { ID int `json:\u0026#34;id\u0026#34;` Time time.Time }{ ID: e.ID, Time: e.Time, }) } 时钟变化 time.Time包含wall和monotonic2种类型.\n其中wall用于一天中确定时间. 比如network time protocol(NTP)中的时间.\n测量持续时间时用的是monotonic\njson例子:\ntype Event3 struct { Time time.Time } func run1() { t := time.Now() event1 := Event3{Time: t} b, err := json.Marshal(event1) if err != nil { fmt.Println(err) return } var event2 Event3 err = json.Unmarshal(b, \u0026amp;event2) if err != nil { fmt.Println(err) return } fmt.Println(event1 == event2) fmt.Println(event1) fmt.Println(event2) } false {2023-10-27 19:26:59.523668 +0800 CST m=+0.000127335} {2023-10-27 19:26:59.523668 +0800 CST} 其中2023-10-27 19:26:59.523668 +0800 CST m=+0.000127335\nwall指的是2023-10-27 19:26:59.523668 +0800 CST monotonic指的是m=+0.000127335 时间通过json的encode decode后不相等,可用fmt.Println(event1.Time.Equal(event2.Time))判断\n可以设置t.Truncate(0)剥离monotonic\nt := time.Now() event1 := Event3{ Time: t.Truncate(0), } 文中还点到了time.Now().In(location)切换时区.\nany时数值变成了float64 根据JSON规范,数值类型默认解码为float64\nfunc f5() { var i int = 12 // int d, err := json.Marshal(i) if err != nil { fmt.Println(err) } var m any // any err = json.Unmarshal(d, \u0026amp;m) if err != nil { fmt.Println(err) } fmt.Printf(\u0026#34;%T\\n\u0026#34;, m) } float64 78 SQL # sql.Open(\u0026quot;mysql\u0026quot;, dsn)只验证参数,不创建连接\n准备就绪后可用db.Ping()真正建立连接\n连接池功能\nSetMaxOpenConns SetMaxIdleConns SetConnMaxIdleTime SetConnMaxLifetime,一般小于数据库的wait_timeout SQL预编译\n提高性能,避免重复编译 参数化SQL值安全性高 方便语句重用 stmt, err := db.Prepare(\u0026quot;SELECT * FROM ORDER WHERE ID = ?\u0026quot;)\n记住还有context传播函数,PrepareContext 和 QueryContext\nsql.NullString主要用来处理数据库表字段可能为空(NULL)的字符串(string)类型的数据.\n类似处理null字段还有sql.NullBool 等等\nrows遍历存在错误处理\nrows, err := db.QueryContext(ctx, \u0026#34;select id, name from users\u0026#34;) if err != nil { // handle error return } defer rows.Close() for rows.Next() { var id int var name string err := rows.Scan(\u0026amp;id, \u0026amp;name) if err != nil { // handle scan error return } // process row data } err = rows.Err() if err != nil { // The query failed return } // No error, all good 执行查询错误 rows, err := db.QueryContext\n关闭rows错误 err := rows.Close()\n扫描rows错误 err := rows.Scan(\u0026amp;department, \u0026amp;age)\n是为了判断结果集迭代是否正常完成,还是因错误而提前终止的 rows.Err()\n79 忘记关闭资源 # HTTP客户端 避免资源泄漏\nresp, err := h.client.Post if err != nil { return } defer func(){ // HTTP客户端请求后的body记得关闭.无论是否读取body err=resp.Body.Close() } 服务端则会自动执行,只是客户端需要关闭\n关于无论如何客户端body都要执行关闭原因\n如果不读取body内容,直接关闭body,默认HTTP客户端可能会主动关闭连接 如果读取了body的部分或全部内容后再关闭,默认HTTP客户端不会主动关闭连接 所以执行resp.Body.Close()是必要的保证\n使用keep-alive时,即使不用body还是需要执行读取.\n_, _ = io.Copy(io.Discard, resp.Body) 具体原因 https://go.dev/src/net/http/response.go#L63\nThe default HTTP client\u0026rsquo;s Transport may not\n// reuse HTTP/1.x \u0026ldquo;keep-alive\u0026rdquo; TCP connections if the Body is\n// not read to completion and closed.\n为了复用 HTTP/1.x \u0026ldquo;keep-alive\u0026quot;的TCP链接,如果body没有读取完整和关闭的情况下是无法做到的.\nsql.Rows rows, err := db.Query if err!=nil{ return } rows.Close() //不使用则会连接泄漏 os.File f, err := os.OpenFile if err!=nil{ return } f.Close() //记得 文件写入时f.Sync()可安全忽略f.Close()错误.\n80 reply HTTP request后忘记return # func Handler(w http.ResponseWriter, r *http.Request) { // 处理请求逻辑 // 返回响应 w.WriteHeader(200) w.Write([]byte(\u0026#34;Hello World\u0026#34;)) return //记得return 防止后面还有逻辑 } 若迟迟不return 发生覆盖现象,出现重复的header头之类.\n81 使用默认的HTTP端 # 客户端和服务端都有config配置,多个timeout参数,需要一一浏览.\n客户端一般流程:\ndial TLS 握手 请求 读取header 读取body 客户端timeout配置可以控制以上流程节点超时设置.\n默认启用连接池,若主动禁止则http.Transport.DisableKeepAlives\n连接空闲超时http.Transport.IdleConnTimeout\nhttp.Transport.MaxIdleConns最大空闲数\nhttp.Transport.MaxIdleConnsPerHost主机最大空闲连接数\n服务端一般流程:\n等待客户端请求 TLS握手 读取请求header 读取body 响应 服务端timeout配置可以控制以上流程节点超时设置.\n"},{"id":10,"href":"/100-go-mistakes-chinese/docs/ch11/","title":"11. 测试","section":"Docs","content":" 82 测试类别 # 分类:\n端到端测试 集成测试 单元测试 构建标记\n//go:build foo package bar 可用于类似go test --tags=integration -v . 来指定运行某些tag测试文件.\n用环境变量选择测试分支执行\n长久运行跳过\nif testing.Short() { t.Skip(\u0026#34;skipping long-running test\u0026#34;) } go test -short -v .\n83 race标记 # 进行数据竞争检测\ngo test -race ./... 84 测试执行模式 # t.Parallel()在go test中用于并行执行测试用例\ngo test -shuffle=on -v .乱序执行\n85 表格驱动测试 # 可用IDE帮助生成\n86 测试中休眠 # 可用sleep进行测试并发场景.\n87 time API测试 # 比如业务中使用time.Now作为变量,影响了测试.\n需要考虑如何覆盖测试到.\n88 测试包推荐 # https://pkg.go.dev/net/http/httptest\nhttps://pkg.go.dev/testing/iotest\n89 benchmarks # b.ResetTimer()可重置benchmarks计时器.\n测试环境机器工作负载会影响benchmarks结果.\n存在编译器优化会影响benchmarks结果,例如被测试函数过于简单被内联inlining.\n内联伪代码\n// 原始函数 function add(a, b) { return a + b; } // 主函数调用函数 function main() { var x = add(1, 2); } // 经过内联优化后 function main() { // 将add函数定义插入main函数中 var x; { var a = 1; var b = 2; x = a + b; } } 观察者效应是测试代码自身可能影响到测试对象的行为.\n90 其他测试功能 # 代码覆盖率 从使用者角度设计测试函数 编写函数方便测试 启动与关闭资源函数用于测试初始化 "},{"id":11,"href":"/100-go-mistakes-chinese/docs/ch12/","title":"12. 优化","section":"Docs","content":" 91 CPU缓存 # CPU架构 i5-7300 2个物理内核,4个逻辑内核. graph TD subgraph CPU subgraph core0 C0_T0[T0] C0_T1[T1] C0_L1D[L1D] C0_L1I[L1I] C0_L2[L2] C0_T0 \u003c--\u003eC0_L1D C0_T0 \u003c--\u003eC0_L1I C0_T1 \u003c--\u003eC0_L1D C0_T1 \u003c--\u003eC0_L1I C0_L1D\u003c--\u003eC0_L2 C0_L1I\u003c--\u003eC0_L2 end subgraph core1 T0 \u003c--\u003e L1D T0 \u003c--\u003e L1I T1 \u003c--\u003e L1D T1 \u003c--\u003e L1I L1D\u003c--\u003eL2 L1I\u003c--\u003eL2 end L2\u003c--\u003eL3 C0_L2\u003c--\u003eL3 end m1[Main memory] L3 \u003c--\u003e m1 cache大小\nL1: 64KB L2: 256KB L3: 4MB 访问速度.\nL1: 1ns L2: 1/4 L1速度 L3: 1/10 L1速度 主存: 1/50~1/100 L1速度 L1 可以挂上100个变量,推算关系\u0026ndash;L1存储大小/变量大小=变量数量.\n缓存行相关 访问特定内存位置时\n同位置再次引用 附近内存位置将被引用 同位置再次引用\nint a = arr[0]; //代码运算 int b = arr[0]; 第二次访问arr[0]时,数据仍在CPU缓存中,直接从缓存中获取,速度更快.\n附近内存位置将被引用\nint a = arr[0]; int b = arr[1]; int c = arr[2]; 访问arr[0],会同时读入arr[0]-arr[N]到缓存.\n以上为局部性原理体现. slice与结构体 type Foo struct { a int64 b int64 } type Bar struct { a []int64 b []int64 } 在sum(a)计算中,Bar比[]Foo紧凑.\n大概分布\n# []Foo a b a b a b a b # Bar a a a a b b b b 预测性 CPU stride // CPU在连续访问内存地址时,两个地址之间的间隔大小. 大概CPU步幅意思.\nCPU stride类型\nunit stride 可预测 constant stride 可预测但低效 non-unit stride 不可预测 type node struct { value int64 next *node } node是链表,node.value的sum计算就是constant stride类型.\n[]int64的sum计算就是unit stride类型. Cache placement policy 当CPU决定复制内存块并将其放入缓存时,遵守的策略.\n常见策略\nFully associative Set associative Set associative比较主流,如下图所示.\ngraph TD A[内存地址] --\u003e B(索引) B --\u003e C{组选择} C --\u003e D1[组1块1] C --\u003e D2[组1块2] C --\u003e D3[组1块3] C --\u003e D4[组2块1] C --\u003e D5[组2块2] 92 错误共享 # 多个协程处理时,结构体padding作用.\ntype Result struct { sumA int64 _ [56]byte sumB int64 } 如果没有padding\nsumA和sumB可能共享一个Cache line,读写时可能发生Cache冲突 保存sumA结果时会污染sumB所在Cache line的数据 读取sumB时更高概率需要从内存重新加载Cache padding存在优化内存对齐和Cache利用率.\n93 指令并行 # func add(s [2]int64) [2]int64 { for i := 0; i \u0026lt; n; i++ { s[0]++ if s[0]%2 == 0 { s[1]++ } } return s } func add2(s [2]int64) [2]int64 { for i := 0; i \u0026lt; n; i++ { v := s[0] // v的存在降低读写冲突 s[0] = v + 1 if v%2 != 0 { s[1]++ } } return s } add2的优化让存在instruction-level parallelism (ILP)特性的CPU对其优化.\n94 数据对齐 # byte, uint8, int8: 1 byte uint16, int16: 2 bytes uint32, int32, float32: 4 bytes uint64, int64, float64, complex64: 8 bytes complex128: 16 bytes type Foo struct { b1 byte i int64 b2 byte } 优化后\ntype Foo struct { i int64 b1 byte b2 byte } 95 堆栈 # stack特点\nlast-in, first-out (LIFO) heap上的变量规则\n全局变量 发送chan的指针变量 chan值里面的结构体嵌套指针 局部变量过大时 无法预估变量大小 96 降低内存分配 # 设计接口时考虑到逃逸分析\nsync.Pool有利于对象重用\n97 内联 # 函数过于复杂则不会内联.\n98 profiling # Golang性能剖析\n99 垃圾回收 # GC流程\nmark sweep GOGC参数控制触发GC的频率,值越大触发GC的频率越低\n频繁GC与延迟有关.\n100 k8s调度 # golang应用跑在k8s,在cpu调度上目前存在问题.\nk8s目前的调度策略 Completely Fair Scheduler (CFS)\n配置k8s配置上cpu CFS的参数\ncpu.cfs_period_us (global setting) cpu.cfs_quota_us (setting per Pod) https://github.com/golang/go/issues/33803 提出了相关的问题,\n其中 https://github.com/uber-go/automaxprocs 让 GOMAXPROCS 自动根据 CPU 配额进行配置.\n"}]